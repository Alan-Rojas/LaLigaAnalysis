# -*- coding: utf-8 -*-
"""LaLiga_Análisis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16t-o_6qB1LETkxNfh2J4hXM3OELoEgNv
"""

!pip install fuzzywuzzy

# Análisis de La Liga Santander

#Import libraries
import pandas as pd
import numpy as np
from google.colab import files
from sklearn.preprocessing import StandardScaler
from fuzzywuzzy import fuzz

"""Cleaning the data bases"""

# Bases de Datos:
players = pd.read_csv("LaLigaPlayers-20222023.csv")
player_market = pd.read_csv('La_Liga_Market_Values.csv')

#players.info() looking at Nan values.
players['Goals'].fillna(0, inplace = True)
players['App'].fillna(0,inplace = True)
players['Assist'].fillna(0, inplace = True)
players['YC'].fillna(0,inplace = True)
players['RC'].fillna(0,inplace = True)
players['AerialDuelsWon'].fillna(0,inplace = True)
players['ShotsPerGame'].fillna(0, inplace = True)
players['MOTM'].fillna(0, inplace=True)
#players.info() fixed.
#Some players had 0 App, but minutes played. So the average game played was inputted.
players.loc[players['App']==0, 'App'] = round(players["MinP"]/90, ndigits = 0)
players.App[16] = str(players.App[16])
#players.head(20) fixed.
# Changing to str so it can look up parenthesis
#players['App'] = str(players['App'])
# Separating subsitute played games from App.

def in_parenthesis(df):
  if '(' in df and ')' in df:
    if df[df.index('(')+1] == ')':
      return 0
    return df[df.index('(') + 1:df.index(')')]
  else:
    return 0

players['SubApp'] = players.App.apply(in_parenthesis)

#
# players.head(20) Fixed.
# Splitting App to only inlcude App and not SubApp as well.
players['App'] = players['App'].apply(lambda s: s.split('(')[0])

#

#players.to_csv('LaLigaPlayers_1.0-20222023.csv', index = False)
#files.download('LaLigaPlayers_1.0-20222023.csv')
# Downloaded file to change datatype
#players.head(20)

player_market.info()

len(player_market)

# odd rows contain the market value of the player above.
def fix_market_value(df, n_column):
    # New DataFrame
    n_df = pd.DataFrame(columns = ['Player_name', 'Market_Value', 'Squad'])
    column = df[n_column]
    i =0
    while i < (len(column)-1):
      act_element = column.iloc[i]
      next_element = column.iloc[i+1]

# Look for prices
      if '€' not in act_element:
        if '€' in next_element:
          n_df = n_df.append({'Player_name': act_element, 'Market_Value': next_element.replace('€',''), 'Squad': df['squad'].iloc[i]}, ignore_index = True)
        else:
          n_df = n_df.append({'Player_name': act_element, 'Market_Value': 0, 'Squad': df['squad'].iloc[i]}, ignore_index = True)
      else:
        df.drop(i, axis = 0)
      print(i)
      i+=1
    return n_df

market = fix_market_value(player_market, 'player_name')

market.head()

# fixing now to common currency
def to_mill(df, n_column):
  new_col = []

  for i in range(len(df)):
    element = df.loc[i, n_column]
    element = str(element)

    if 'k' in element:
      element = element.replace('k','')
      element = float(element)
      if element > 100:
        element = element/1000
      else:
        element = element/10000
    elif 'm' in element:
      element = element.replace('m', '')
      element = float(element)
    new_col.append(element)
  df['MarketV_Mill'] = new_col

to_mill(market, 'Market_Value')
#market.head() fixed
market = market.drop('Market_Value', axis = 1)

market.head()

#market.head() fixed
market.rename(columns={'Player_name':'Player_Name'}, inplace=True)
market.head()

players_numeric = pd.read_csv('LaLigaPlayers_1.0-20222023.csv')
#players_numeric.describe()
# Now with all the numeric variables in a single dataset, we can procede with the reduction by PCA
players_numeric.rename(columns={'Team-name': 'Squad'}, inplace= True)
players_numeric.rename(columns={'Player Name': 'Player_Name'}, inplace= True)
players_numeric.head()

# Merge Market value with palyers_numeric
# Since sqads are already sorted by alphabetical order, procedure si to sort by Player Name
players_numeric.sort_values(by= ['Squad', 'Player_Name'], inplace = True)
market.sort_values(by=['Squad', 'Player_Name'], inplace = True)
market.info()

players_numeric.info()

len(players_numeric.loc[players_numeric['Squad']== 'Almeria', 'Player_Name'])

# Merge market value and player_numeric
# Since names are not the same, we will use the fuzzywuzzy lib to compare similarity
#Here is an example
#print(fuzz.ratio('Andrés Fuentes', 'Andres Fnts')) output: 80. So 80% will be our parameter to merge names.
def merge_by_similarity(df1, df2, column1, column2):
    Market_Value = [np.nan] * len(df1)

    for i in range(len(df1)):
        for j in range(len(df2)):
            if fuzz.ratio(df1[column1].iloc[i], df2[column1].iloc[j]) >= 70 and df1[column2].iloc[i] == df2[column2].iloc[j]:
                Market_Value[i] = (df2['MarketV_Mill'].iloc[j])

    df1['Market_Value'] = Market_Value

merge_by_similarity(players_numeric, market, 'Player_Name', 'Squad')

players_numeric['Market_Value'].fillna(0.0,inplace = True)

players_numeric.to_csv('LaLigaPlayers_2.0-20222023.csv', index = False)
files.download('LaLigaPlayers_2.0-20222023.csv')

"""# Reducción mediante PCA"""

# We begin by standarizing all the variables, so they do not overcompensate other variables with less numeric value.
players_std = players_numeric
players_std = StandardScaler().fit_transform(players_std)
print(players_std)

# We procede to create a covariance matrix that will allow us to determine how the data relates within itself.
cov_players_std = np.cov(players_std)
cov_players_std

# Finding the eigenvalues and eigenvectors of that matrix, this is useful to determine the Principal components.
cps_Evalues, cps_Evectors = np.linalg.eig(cov_players_std)
cps_Evectors

# Organizing eigenvectors acording to the highest eigenvalue
def PCA(A, B): #Note that A is the array of eigenvalues and B is the matrix of eigenvectors.
# The main focus is to find the top 5 components of the analysis.
  max_index = 0

  n_matrix = [[]]
  for n in range(0,5):
    for i in range(len(A)):
      if A[i] < A[i+1]:
        max_index = i+1
    A.pop(max_index)
    for j in range(len)
    n_matrix[n][B[max_index][0], ]